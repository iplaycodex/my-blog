<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[记一次微信小程序转字节跳动小程序的经验]]></title>
    <url>%2F2019%2F12%2F26%2F%E8%AE%B0%E4%B8%80%E6%AC%A1%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E8%BD%AC%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E5%B0%8F%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BB%8F%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[[TOC] 1.前言公司最近有个需求是把已经存在的用微信原生开发的微信小程序转为字节跳动小程序(以下简称头条小程序).因为给的开发时间太短,重写基本不可能.遂 google 寻找可以方便快速将微信小程序转为头条小程序的方法.现将整个过程归纳总结如下,方便没有做过的同学可以快速上手,也方便自己记录.毕竟好记性不如烂笔头~Orz… 2.准备工作 1.申请字节跳动开发者账号 2.申请头条小程序,配置相关账号权限 3.小程序类别如果为特殊类别,确认是否需要相关资质 4.配置相关域名,注意:必须为https 5.主体认证申请 6.申请开通支付 7.下载开发工具3.技术选型3.1 如何做? 上面已经说了,从 0 开发是不可能的.所以我们需要一个工具可以把小程序的源码转为头条小程序的代码.经过各方调研,有以下三种工具.3.2 taro? uniApp? wx2bat? 名称 特性 语法风格 官网 taro 京东出品,一种类react的语法的小程序开发框架,支持一套代码转为微信小程序,H5,百度小程序,支付宝小程序,快应用,ReactNative,字节跳动小程序,QQ 轻应用.可以看到功能还是很强大的,并且支持将原生开发的微信小程序转为taro小程序 react https://taro.aotu.io/ uniApp 也是宣称一套代码打包为不同平台的东西,是一种类vue语法的实现.文档没有taro写得好,目前社区也没有其他框架成熟.了解不是很多,这里就不在赘述了 vue https://uniapp.dcloud.io/ wx2bat 自己开发,使用最简单的一个工具,它主要做的事情:将 wxml 后缀名改为 ttml,将 wxss 后缀名改为 ttss,将 wxml 中 wx: 改为 tt,将 js 中 wx: 改为 tt:.同时支持转为百度小程序,支付宝小程序 各个平台的原生语法 https://www.npmjs.com/package/wx2bat 总结：经过上面的分析和总结,我们可以得出一个结论:上述 3 种转换方式大概的实现思路如下所示: taro和uniApp wx2bat 1.可以看到使用wx2bat优点是比较快速方便,省了中间层的代码.而taro和uniApp则加了一层虽然比较麻烦,但是却可以支持更多的平台. 2.经过本人实践(只试验了 taro),发现错误很多,转换的代码编译后有漏文件的现象,而且错误频频,不停的再解决BUG.考虑到开发时间不充足,遂考虑使用wx2bat来做转换. 实操下来发现成本较低,有一些简单的语法不兼容,稍微修修改改项目就可以快速的跑起来.遂采用wx2bat来解决此次需求 4.转换结果通过wx2bat我们已经可以方便快速的将微信小程序转为头条小程序了.一些修改的细节参见我的github或者npm或者个人站,地址如下所示:iplaycodex 5.遇到的坑 虽然说头条小程序的90%的api 和微信小程序是差不多的,但是还是有一些差异性.需要我们进行手动修改.现归纳总结如下所示: 微信小程序的 .wxs 后缀文件在头条小程序中不支持! 上面已经说了头条小程序 .wxs文件不支持.那自然.wxs中声明的函数在模板中是不能使用的 头条小程序不支持在 中使用函数,更别说过滤器这种东西了,这一点特别坑! 微信小程序互跳的相关逻辑代码需要删除!(即A 微信小程序打开 B 微信小程序) 微信,wechat等微信的关键字要全部删掉,否则可能会审核被拒 获取用户数据的按钮上的 bindgetuserinfo 方法不支持,需要改为普通的bindtap 授权登录这里和微信小程序差不多,不需要过多的修改~ 支付的话,头条小程序支持的比较多,例如支付宝.这里需要根据需求自行修改 等等… 6.结束6.1 结束语到这里项目应该已经可以差不多跑起来了,通过在转换后的头条小程序代码上修修改改进行二次开发,可以很快速的将微信小程序转为头条小程序.接下来就是需要对整个项目进行回归测试了这里就不再赘述了 6.2 参考文档微信小程序官方文档字节跳动小程序官方文档wx2bat文档]]></content>
      <categories>
        <category>小程序</category>
      </categories>
      <tags>
        <tag>小程序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[wx2bat工具分享]]></title>
    <url>%2F2019%2F12%2F22%2Fwx2bat%E5%B7%A5%E5%85%B7%E5%88%86%E4%BA%AB%2F</url>
    <content type="text"><![CDATA[前言最近在公司接到了一个需求:把一个微信小程序快速变成字节跳动小程序,开发时间只有一个星期!显然从 0 开始开发字节跳动的小程序是不可能的.所以只能想办法看如何快速的把微信小程序转为字节跳动小程序~ 解决之道经过查询得知,其他家的小程序的api和微信几乎90%一样,只是可能文件后缀换了自己的后缀.还有一些语法也变了:例如: 12345678// wechatAppwx:if// 头条tt:if// 百度swan:if 这样的话就比较简单了,我们只需要写一个工具把哪些差异性的东西修改一下就可以了.经过半天的辛苦编码:wx2bat工具写完了,支持将微信小程序源码快速转为百度小程序,支付宝小程序以及头条小程序.并已经发布到了npm上面 如何使用?step 1: 1npm i -g wx2bat step 2: 1wx2bat &lt;wechatAppPath&gt; &lt;outputPath&gt; &lt;platform&gt; 通过上面一行命令即可将微信小程序的源码转为目标小程序的源码.然后需要修改一下特定平台的差异性代码即可.例如:授权登录,支付,分享… 相关链接wx2bat]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用charles来拦截请求和响应]]></title>
    <url>%2F2019%2F11%2F12%2F%E5%88%A9%E7%94%A8charles%E6%9D%A5%E6%8B%A6%E6%88%AA%E8%AF%B7%E6%B1%82%E5%92%8C%E5%93%8D%E5%BA%94%2F</url>
    <content type="text"><![CDATA[今天简单分享一下如何使用charles来进行HTTP的拦截和修改. charles是一款非常好用的http调试工具,相信做开发的同学们应该都知道其实使用charles来做HTTP拦截很简单. 1.拦截请求打开charles,在输入框中输入要拦截的API地址:在API上鼠标右键选择breakPoint即可打个断点.然后重新请求的时候这个HTTP就会被拦截,如下所示: 切到Edit Requesttab即可修改request的入参,如下图所示: 2.拦截响应修改返回的数据:其实也是很简单的操作,这里写出来分享给不知道的同学. PS:修改请求或者响应的时候要快一点,否则容易失败!切记!]]></content>
      <categories>
        <category>调试</category>
      </categories>
      <tags>
        <tag>调试</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node自动重启工具nodemon]]></title>
    <url>%2F2019%2F11%2F07%2Fnode%E8%87%AA%E5%8A%A8%E9%87%8D%E5%90%AF%E5%B7%A5%E5%85%B7nodemon%2F</url>
    <content type="text"><![CDATA[问题在开发Node.js的项目的时候,需要频繁的手动close掉,然后再重启,非常麻烦.经过百度以后发现了一个好用的工具:nodemon.它的作用是监听代码文件的变动,当代码改动了以后,自动重启. 如何使用打开终端,win平台使用命令行,输入以下指令完成安装. 1npm install -g nodemon 创建一个index.js,开始写代码,如下所示: 1234567891011var express = require("express")var app = express()app.get('/',function(req,res) &#123; res.send("hello express");&#125;)app.listen(3000,function()&#123; console.log('server is running')&#125;) 往常我们启动这个服务都是使用的是 1node index.js 安装了nodemon后就不用了,可以使用: 1nodemon index.js 启动.这个时候当我们修改以下源码就会看到node自动重启了.我们刷新一下浏览器,会发现内容已经更新了]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模仿vue-cli写一个简单脚手架]]></title>
    <url>%2F2019%2F11%2F04%2F%E6%A8%A1%E4%BB%BFvue-cli%E5%86%99%E4%B8%80%E4%B8%AA%E7%AE%80%E5%8D%95%E8%84%9A%E6%89%8B%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[[TOC] 前言我的朋友们,你是否遇到过下面的这种情况.每当要开始做新项目的时候(此文档仅针对vue,后续会继续扩展),每次都需要使用vue-cli去初始化一个项目: 12// init your project by vue-cli with webpack templatevue init webpack yourProject 一顿操作猛如虎生成了一个基于webpack的项目.BUT距离开箱即用还是有一点距离.如果你的项目是个移动端的项目,那么针对移动端又需要安装大量的插件,第三方库.包括不限于如下所示: fastclick babel-polyfill reset.css border.css rem.js flexable.js axios qs … 一遍一遍,真的是烦的要死.而且现在是一个强调工程化的时代,任何可以交给程序的东西都交给程序自动化的去做.而且每次这样做也不利于项目的一致性,规范性.如果你是一个团队owner,如何统一化开发流程,如何解决这个问题.则迫在眉睫. 既然产生了问题,那么就要解决问题. 思路前面的文章本人已经分享了自己编写的HTML开发规范,CSS开发规范以及Javascript开发规范.通过code-review来规范HTML和CSS的开发,通过eslint来规范javascript的开发. 通过eslint来规范js的开发,本人会在这个集合中再写一篇专门介绍如何使用eslint来规范js的开发. 1.模板既然vue-cli官方提供的模板不满足我们的需求(vue inint webpack project其实就是下载一个webpack的模板),那么我们就自定义一个满足自己项目需求的模板.在这个模板中配置好上述的所有插件,第三方库,工具类,布局组件,ui库,eslint,webpack配置等等… 做到真正的开箱即用,满足我们项目的使用. 2.cli]]></content>
      <categories>
        <category>前端工程化</category>
      </categories>
      <tags>
        <tag>前端工程化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[npm ERR! publish Failed PUT 403]]></title>
    <url>%2F2019%2F11%2F02%2Fnpm-ERR-publish-Failed-PUT-403%2F</url>
    <content type="text"><![CDATA[问题最近遇到的一个问题,最近在npm发布了一个包.使用命令npm publish之后发生了如下错误: 12345npm ERR! code E403npm ERR! 403 Forbidden - PUT https://registry.npm.taobao.org/kda-cli - [no_perms] Private mode enable, only admin can publish this modulenpm ERR! A complete log of this run can be found in:npm ERR! /Users/allenliu/.npm/_logs/2019-11-02T05_52_32_439Z-debug.log 出现这个问题呢,一般都是因为修改了npm的源.我们可以在很多文档上看到因为国内的网络问题,很多时候文档上都建议修改npm的源为taobao源. 解决方法如下所示:1.查看npm是否被设置成了taobao源,打开终端,输入:1npm config get registry 这个时候会如下显示:(如果非淘宝源头也就不会出现上述问题了) 1https://registry.npm.taobao.org/ 2.设置为官方源同样,打开终端输入以下指令: 1npm config set registry=http://registry.npmjs.org 3.登录npm账户(如果没有登录),再次发布12345// step 1npm login 或者添加用户 npm adduser// step 2npm publish 4.发布成功之后根据需求再次将源设置为taobao镜像1npm config set registry=https://registry.npm.taobao.org/ PS:不建议设置为淘宝源,建议找一个稳定的VPN.或者推荐安装yarn.cnpm在安装依赖包的时候会经常发生一些莫名其妙的问题]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发规范之Javascript]]></title>
    <url>%2F2019%2F10%2F31%2Fweb%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E4%B9%8BJavascript%2F</url>
    <content type="text"><![CDATA[团队内部整理的一份Javascript开发规范,供参考 写在前面 JavaScript 作为最常用的前端编程语言，其编码规约是前端规范的重要组成部分。 ECMAScript 6.0（即 ES6/ES2015）作为 JavaScript 语言的下一代标准，于 2015 年 6 月正式发布。ES6 引入了诸多新的语言特性，与之前的 JS 版本有很大差异，因此业界通常会以 ES6、ES5 模糊地区别 ES6 之后（包括 ES2016/ES2017..）、之前的 JS 版本，本规约中也会使用这种模糊的叫法。 ES6 经过几年的普及，已经成为未来使用的大趋势，尤其是新代码库基本都会使用 ES6 编码。 因此，本规范使用 ES6 编写。对于还在使用 ES5 及之前版本 JS 的同学，本规范的大部分内容也适用。编码风格1.缩进 【强制】使用 4 个空格缩进。eslint: indent.统一使用 4个空格缩进，不要使用 2个空格或 tab 缩进： 12345678// badfunction foo() &#123;∙∙let name;&#125;// goodfunction foo() &#123;∙∙∙∙let name;&#125; 2.分号【强制】用分号。eslint: semi.统一以分号结束语句，可以避免 JS 引擎自动分号插入机制的怪异行为，在语义上也更加明确。 12345678910111213141516171819202122232425262728293031323334// bad - 导致 Uncaught ReferenceError 报错const luke = &#123;&#125;const leia = &#123;&#125;[luke, leia].forEach((jedi) =&gt; &#123; jedi.father = 'vader'&#125;) // goodconst luke = &#123;&#125;;const leia = &#123;&#125;;[luke, leia].forEach((jedi) =&gt; &#123; jedi.father = 'vader';&#125;); // bad - 导致 Uncaught ReferenceError 报错const reaction = "No! That's impossible!"(async function meanwhileOnTheFalcon() &#123;&#125;()) // goodconst reaction = "No! That's impossible!";(async function meanwhileOnTheFalcon() &#123;&#125;()); // bad - 函数将返回 `undefined` 而不是换行后的值function foo() &#123; return 'Result want to be returned'&#125; // goodfunction foo() &#123; return 'Result want to be returned';&#125; 3.逗号1.【强制】对于用逗号分隔的多行结构，不使用行首逗号。eslint:comma-style 123456789101112131415161718192021222324252627// badconst story = [ once , upon , aTime]; // goodconst story = [ once, upon, aTime,]; // badconst hero = &#123; firstName: 'Ada' , lastName: 'Lovelace' , superPower: 'computers'&#125;; // goodconst hero = &#123; firstName: 'Ada', lastName: 'Loveplace', superPower: 'computers',&#125;; 2.【强制】对于用逗号分隔的多行结构，始终加上最后一个逗号。eslint:comma-dangle 这样可以使增删行更加容易，也会使 git diffs 更清晰。Babel 等编译器会在编译后的代码里帮我们去掉最后额外的逗号，因此不必担心在旧浏览器中的问题。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374// bad - 没有结尾逗号时，新增一行的 git diff 示例const hero = &#123; firstName: 'Florence',- lastName: 'Nightingale'+ lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing']&#125;; // good - 有结尾逗号时，新增一行的 git diff 示例const hero = &#123; firstName: 'Florence', lastName: 'Nightingale',+ inventorOf: ['coxcomb chart', 'modern nursing'],&#125;; // badconst hero = &#123; firstName: 'Dana', lastName: 'Scully'&#125;; const heroes = [ 'Batman', 'Superman']; function createHero( firstName, lastName, inventorOf) &#123; // ...&#125; createHero( firstName, lastName, inventorOf); // goodconst hero = &#123; firstName: 'Dana', lastName: 'Scully',&#125;; const heroes = [ 'Batman', 'Superman',]; function createHero( firstName, lastName, inventorOf,) &#123; // ...&#125; createHero( firstName, lastName, inventorOf,); // good - 需注意，使用扩展运算符的元素后面不能加逗号function createHero( firstName, lastName, inventorOf, ...heroArgs) &#123; // ...&#125; 块1.【推荐】始终使用大括号包裹代码块。eslint: curly,nonblock-statement-body-position多行代码块必须用大括号包裹 12345678910// badif (foo) bar(); baz(); // 这一行并不在 if 语句里 // goodif (foo) &#123; bar(); baz();&#125; 代码块只有一条语句时，可以省略大括号，并跟控制语句写在同一行。但出于一致性和可读性考虑，不推荐这样做： 1234567891011// badif (foo) return false; // bad - 允许但不推荐if (foo) return false; // goodif (foo) &#123; return false;&#125; 2.【强制】对于非空代码块，大括号的换行方式采用 Egyptian Brackets 风格。eslint: brace-style具体规则如下： 左大括号 { 前面不换行，后面换行 右大括号 } 前面换行 右大括号 } 后面是否换行有两种情况： 如果 } 终结了整个语句，如条件语句、函数或类的主体，则需要换行 如果 } 后面存在 else、catch、while 等语句，或存在逗号、分号、右小括号（)），则不需要换行 1234567891011121314// bad - else 应与 if 的 &#125; 放在同一行if (foo) &#123; thing1();&#125;else thing2();&#125; // goodif (foo) &#123; thing1();&#125; else &#123; thing2();&#125; 3.【推荐】对于空代码块，且不在类似 if...else... 或try..catch..finally.. 的多块结构中时，可以立即将大括号闭合。eslint:brace-style 12// goodfunction doNothing() &#123;&#125; 如果空代码块在多块结构中，则仍需要按上一条非空块的规则换行： 1234567891011121314151617181920212223242526// badif (condition) &#123; // …&#125; else if (otherCondition) &#123;&#125; else &#123; // …&#125; // goodif (condition) &#123; // …&#125; else if (otherCondition) &#123;&#125; else &#123; // …&#125; // badtry &#123; // …&#125; catch (e) &#123;&#125; // goodtry &#123; // …&#125; catch (e) &#123;&#125; 4.【强制】不要让代码中出现空代码块，这会使阅读者感到困惑。如果必须使用空块，需在块内写明注释。eslint: no-empty 123456789101112// badif (condition) &#123; thing1();&#125; else &#123;&#125; // goodif (condition) &#123; thing1();&#125; else &#123; // TODO I haven’t determined what to do.&#125; 空格1.【强制】块的左大括号 { 前有一个空格。eslint:space-before-blocks 123456789101112131415161718192021// badfunction test()&#123; console.log('test');&#125; // goodfunction test() &#123; console.log('test');&#125; // baddog.set('attr',&#123; age: '1 year', breed: 'Bernese Mountain Dog',&#125;); // gooddog.set('attr', &#123; age: '1 year', breed: 'Bernese Mountain Dog',&#125;); 2.【强制】控制语句（if、while 等）的左小括号 ( 前有一个空格。声明函数时，函数名和参数列表之间无空格。eslint:keyword-spacing 12345678910111213141516171819// badif(isJedi) &#123; fight ();&#125; // goodif (isJedi) &#123; fight();&#125; // badfunction fight () &#123; console.log ('Swooosh!');&#125; // goodfunction fight() &#123; console.log('Swooosh!');&#125; 3.【强制】小括号内部两侧无空格。eslint: space-in-parens 12345678910111213141516171819// badfunction bar( foo ) &#123; return foo;&#125; // goodfunction bar(foo) &#123; return foo;&#125; // badif ( foo ) &#123; console.log( foo );&#125; // goodif (foo) &#123; console.log(foo);&#125; 4.【强制】方括号内部两侧无空格。eslint: array-bracket-spacing 1234567// badconst foo = [ 1, 2, 3 ];console.log(foo[ 0 ]); // goodconst foo = [1, 2, 3];console.log(foo[0]); 5.【强制】大括号内部两侧有空格。eslint: object-curly-spacing 12345// badconst foo = &#123;clark: 'kent'&#125;; // goodconst foo = &#123; clark: 'kent' &#125;; 6.【强制】运算符两侧有空格，除了一元运算符。eslint:space-infix-ops 1234567891011121314151617// badconst x=y+5; // goodconst x = y + 5; // badconst isRight = result === 0? false: true; // goodconst isRight = result === 0 ? false : true; // bad - 一元运算符与操作对象间不应有空格const x = ! y; // goodconst x = !y; 7.【强制】定义对象字面量时，不允许所谓的「水平对齐」，即 key、value 之间应该有且只有一个空格。eslint: key-spacing 1234567891011121314151617// bad&#123; a: 'short', looooongname: 'long',&#125; // bad&#123; a : 'short', looooongname: 'long',&#125; // good&#123; a: 'short', looooongname: 'long',&#125; 8.【强制】在使用多个（大于两个）方法链式调用时进行换行缩进，把点. 放在前面以强调这是方法调用而不是新语句。eslint:newline-per-chained-call no-whitespace-before-property 12345678910111213141516171819202122232425262728293031323334353637// bad$('#items').find('.selected').highlight().end().find('.open').updateCount(); // bad$('#items'). find('.selected'). highlight(). end(). find('.open'). updateCount(); // good$('#items') .find('.selected') .highlight() .end() .find('.open') .updateCount(); // badconst leds = stage.selectAll('.led').data(data).enter().append('svg:svg').classed('led', true) .attr('width', (radius + margin) * 2).append('svg:g') .attr('transform', `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`) .call(tron.led); // goodconst leds = stage.selectAll('.led') .data(data) .enter().append('svg:svg') .classed('led', true) .attr('width', (radius + margin) * 2) .append('svg:g') .attr('transform', `translate($&#123;radius + margin&#125;,$&#123;radius + margin&#125;)`) .call(tron.led); // good - 大于 2 个方法的链式调用才需要进行换行const leds = stage.selectAll('.led').data(data); 空行1.【推荐】在文件末尾保留一行空行。eslint: eol-last.统一在文件末尾保留一行空行，即用一个换行符结束文件： 12345678910111213// bad - 文件末尾未保留换行符import &#123; foo &#125; from './Foo';// ...export default foo;// bad - 文件末尾保留了2个换行符import &#123; foo &#125; from './Foo';// ...export default foo;↵↵// goodimport &#123; foo &#125; from './Foo';// ...export default foo;↵ 2.【强制】块的开始和结束不能是空行。eslint: padded-blocks 123456789101112131415161718192021222324252627// badfunction bar() &#123; console.log(foo); &#125; // goodfunction bar() &#123; console.log(foo);&#125; // badif (baz) &#123; console.log(qux);&#125; else &#123; console.log(foo); &#125; // goodif (baz) &#123; console.log(qux);&#125; else &#123; console.log(foo);&#125; 3.【参考】在块末和新语句间插入一个空行。 1234567891011121314151617181920212223242526272829303132// badif (foo) &#123; return bar;&#125;return baz; // goodif (foo) &#123; return bar;&#125; return baz; // badconst obj = &#123; foo() &#123; &#125;, bar() &#123; &#125;,&#125;;return obj; // goodconst obj = &#123; foo() &#123; &#125;, bar() &#123; &#125;,&#125;; return obj; 最大字符数和最大行数1.【推荐】单行最大字符数：100。eslint: max-len.过长的单行代码不易阅读和维护，需要进行合理换行。单行代码最多不能超过 100 个字符，除了以下两种情况： - 字符串和模板字符串 - 正则表达式 12345678910111213141516171819202122// badconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy; // goodconst foo = jsonData &amp;&amp; jsonData.foo &amp;&amp; jsonData.foo.bar &amp;&amp; jsonData.foo.bar.baz &amp;&amp; jsonData.foo.bar.baz.quux &amp;&amp; jsonData.foo.bar.baz.quux.xyzzy; // bad$.ajax(&#123; method: 'POST', url: 'https://foo.com/', data: &#123; name: 'John' &#125; &#125;).done(() =&gt; console.log('Congratulations!')).fail(() =&gt; console.log('You have failed this city.')); // good$.ajax(&#123; method: 'POST', url: 'https://foo.com/', data: &#123; name: 'John' &#125;,&#125;) .done(() =&gt; console.log('Congratulations!')) .fail(() =&gt; console.log('You have failed this city.')); 2.【推荐】文件最大行数：1000。eslint: max-lines过长的文件不易阅读和维护，最好对其进行拆分。4.【推荐】函数最大行数：80。eslint: max-lines-per-function过长的函数不易阅读和维护，最好对其进行拆分。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发规范之CSS]]></title>
    <url>%2F2019%2F10%2F31%2Fweb%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E4%B9%8BCSS%2F</url>
    <content type="text"><![CDATA[团队内部整理的一份CSS开发规范,供参考 基本规范1.【推荐】缩进使用四个空格 123456789/* bad */.mod-example &#123; padding-left: 15px;&#125;/* good */.mod-example &#123; padding-left: 15px;&#125; 2.在每个声明块的左花括号前添加一个空格 123456789/* bad */.mod-example&#123; padding-left: 15px;&#125; /* good */.mod-example &#123; padding-left: 15px;&#125; 3.声明块的右花括号应当单独成行 123456789/* bad */.mod-example &#123; padding-left: 15px;&#125; /* good */.mod-example &#123; padding-left: 15px;&#125; 4.每条声明语句的 : 后应该插入一个空格，前面无空格 123456789/* bad */.mod-example &#123; padding-left:15px;&#125; /* good */.mod-example &#123; padding-left: 15px;&#125; 5.所有声明语句都以分号结尾，不能省略不写 123456789/* bad */.mod-example &#123; padding-left: 15px&#125; /* good */.mod-example &#123; padding-left: 15px;&#125; 选择器规范1.为选择器分组时，将单独的选择器单独放在一行 12345678910/* bad */.selector, .selector-secondary &#123; padding-left: 15px;&#125; /* good */.selector,.selector-secondary &#123; padding-left: 15px;&#125; 2.为选择器中的属性添加双引号 123456789/* bad */.selector[type=text] &#123; padding-left: 15px;&#125; /* good */.selector[type="text"] &#123; padding-left: 15px;&#125; 3.建议选择器层级不要超过5级 123456789/* bad */.main .top .left .mod-a .content .detail &#123; padding-left: 15px;&#125; /* good */.mod-a .content .detail &#123; padding-left: 15px;&#125; 属性规范【推荐】建议相关的属性说明放在一组，并按照下面的顺序排列： 定位（position、left、right、top、bottom、z-index） 盒子模型（display、float、width、height、margin、padding、border、border-radius） 排印（font、color、background、line-height、text-align） 由于定位可以从正常的文档流中移除元素，并且还能覆盖盒模型相关的样式，因此排在首位。而盒模型决定了组件的尺寸和位置，所以排第二位。排印只是影响元素的细节样式变化，所以放第三位。 1234567891011121314151617181920212223242526272829303132333435363738394041/* bad */.mod-example &#123; font: normal 13px "Helvetica Neue", sans-serif; display: block; position: absolute; z-index: 100; width: 100px; height: 100px; border: 1px solid #ccc; top: 0; bottom: 0; left: 0; right: 0; line-height: 1.5; text-align: center;&#125;/* good */.mod-example &#123; /* 定位 */ position: absolute; top: 0; right: 0; bottom: 0; left: 0; z-index: 100; /* 盒模型 */ display: block; float: right; width: 100px; height: 100px; margin: 15px auto; padding: 10px 15px; border: 1px solid #ccc; /* 排印 */ font: normal 13px "Helvetica Neue", sans-serif; line-height: 1.5; color: #333; background-color: #f5f5f5; text-align: center;&#125; 简写形式的属性声明对于 background 和 font 这两个简写形式的属性声明，要么就显式声明所有的值，要么就不要使用简写形式。 0 和 单位省略 “0” 值后面的单位。不要在 0 值后面使用单位，除非有值。 123456789/* bad */.mod-example &#123; padding-left: 0px;&#125; /* good */.mod-example &#123; padding-left: 0;&#125; 颜色值十六进制表示法1.在可能的情况下，使用 3 个字符的十六进制表示法，并始终使用小写的十六进制数字 123456789101112/* bad */.mod-example &#123; color: #cccccc; background-color: #efefef;&#125; /* good */.mod-example &#123; color: #ccc; background-color: #efefef;&#125; 2.应避免16进制表示法与rgb表示法混用的情况，并优先使用16进制表示法 123456789101112131415/* bad */.example-part1 &#123; color: #efefef;&#125;.example-part2 &#123; color: rgb(252, 252, 252);&#125; /* good */.example-part1 &#123; color: #efefef;&#125;.example-part2 &#123; color: #fcfcfc;&#125; 小数1.对于使用到小数的情况，省略前边的 0 123456789/* bad */.mod-example &#123; opacity: 0.5;&#125; /* good */.mod-example &#123; opacity: .5;&#125; 引号1.属性选择器或属性值用双引号 &quot;&quot; 括起来，而 URI 值 url() 不要使用任何引号 123456789101112/* bad */body &#123; font-family: open sans, arial, sans-serif; background-image: url('https://allenliu.com.cn/');&#125; /* good */body &#123; font-family: "open sans", arial, sans-serif; background-image: url(https://allenliu.com.cn/);&#125; 自定义 font-family1.对于自定义的 font-family 命名，必须使用业务域名前缀作为名字的开始，例如淘宝爱逛街的自定义字体： 123456789101112/* bad */@font-face &#123; /* 业务自定义字体 */ font-family: icon-font; src: url(//allenliu.com.cn/yyw/wap/home/static/fonts/iconfont.969ef42.woff);&#125; @font-face &#123; /* 业务自定义字体 */ font-family: guang-iconfont; src: url(//allenliu.com.cn/yyw/wap/home/static/fonts/iconfont.969ef42.woff);&#125; 媒体查询(Media query)规约媒体查询建议根据需要采用下面两种组织形式： 将媒体查询放在尽可能相关规则的附近，不要放在文档底部，否则容易被后来维护的人遗忘 媒体查询针对每一个种屏幕（大、中、小）的分别单独组织为一个文件 例如: 1234567891011121314.element &#123;&#125;.element-avatar &#123;&#125;.element-selected &#123;&#125;@media (min-width: 480px) &#123; .element &#123; &#125; .element-avatar &#123; &#125; .element-selected &#123; &#125;&#125; 例如: 1234567891011121314151617.element &#123;&#125;.element-avatar &#123;&#125;.element-selected &#123;&#125; /* base-media-small.css */@media (min-width: 480px) &#123; .element &#123; &#125; .element-avatar &#123; &#125; .element-selected &#123; &#125;&#125; 注释规范代码是由人来编写和维护的。保证你的代码是描述性的，包含好的注释，并且容易被他人理解。好的代码注释传达上下文和目标。不要简单地重申组件或者 class 名称。 1234567891011/* bad */ /* Modal header */.modal-header &#123;&#125; /* good */ /* Wrapping element for .modal-title and .modal-close */.modal-header &#123;&#125; 文件注释文件注释，即声明在文件头部，描述文件的元信息，表明这个文件的作用是什么，如下例子： 123456/** * 这个文件的作用是什么，巴拉巴拉 */body &#123; color: red;&#125; 命名规范1.小写字母加连字符(也叫烤串命名法),禁止下划线和驼峰命名 1234567891011/* bad */.mod_example &#123; padding-left: 15px;&#125;.modExample &#123; padding-left: 15px;&#125;/* good */.mod-example &#123; padding-left: 15px;&#125; 3.需要在 javascript 中使用的类名以 J_ 开头，接“大驼峰”命名。例如J_ExampleClass， 并且这类的 class 不能出现在 CSS 文件中 123456&lt;!-- Bad Html Class for Javascript Hook --&gt;&lt;div class="mod-example"&gt;&lt;/div&gt; &lt;!-- Good Html Class for Javascript Hook --&gt;&lt;div class="J_ExampleClass"&gt;Just a Example&lt;/div&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发规范之HTML]]></title>
    <url>%2F2019%2F10%2F31%2Fweb%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83%E4%B9%8BHTML%2F</url>
    <content type="text"><![CDATA[团队内部整理的一份HTML开发规范,供参考 基本规范1.HTML5 doctype在每个 HTML 页面开头使用这个简单地 doctype 来启用标准模式，使其每个浏览器中尽可能一致的展现。 12345678910111213&lt;!-- bad --&gt;&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt;&lt;/html&gt; &lt;!-- good --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;/head&gt;&lt;/html&gt; 2.字符编码由于历史原因，X系不同产品都是采用了不同的字符编码。对于以后的新业务如无特殊要求，统一使用 UTF-8 字符编码，便于统一。 3.Language attribute根据 HTML5 规范：鼓励网站作者在 html 元素上指定 lang 属性，来指出页面的语言。这样做会有助于语言合成工具来确定怎样发音，以及翻译工具决定使用的规则，等等。 4.IE 兼容模式Internet Explorer 支持使用兼容性 &lt;meta&gt; 标签来指定使用什么版本的 IE 来渲染页面。如果不是特殊需要，通常通过 edge mode 来通知 IE 使用最新的兼容模式。 1&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1"&gt; 5.引入 CSS 和 JavaScript 1.根据 HTML5 规约, 通常在引入 CSS 和 JavaScript 时不需要指明 type，因为text/css 和 text/javascript 分别是他们的默认值. 12345678910111213&lt;!-- bad --&gt;&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;link type="text/css" rel="stylesheet" href="code-guide.css"&gt; &lt;script type="text/javascript" src="example.js"&gt;&lt;/script&gt;&lt;/head&gt; &lt;!-- good --&gt;&lt;!DOCTYPE html&gt;&lt;head&gt; &lt;link rel="stylesheet" href="code-guide.css"&gt; &lt;script src="example.js"&gt;&lt;/script&gt;&lt;/head&gt; 2.此外，引入 CSS 必须在 &lt;head&gt;&lt;/head&gt; 标签里引入。对于引入 Javascript，除了基础库等比较基础性的脚本文件，其他都在靠近 body 结束标签前面引入。 123456789101112131415161718192021222324252627282930&lt;!-- bad --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;script src="mod-a.js"&gt;&lt;/script&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;style&gt; .mod-example &#123; padding-left: 15px &#125; &lt;/style&gt; &lt;/body&gt;&lt;/html&gt; &lt;!-- good --&gt;&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;style&gt; .mod-example &#123; padding-left: 15px &#125; &lt;/style&gt; &lt;script src="jquery.js"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 6.缩进使用四个空格123456789&lt;!-- bad --&gt;&lt;div&gt; &lt;p&gt;just a example&lt;/p&gt;&lt;/div&gt; &lt;!-- good --&gt;&lt;div&gt; &lt;p&gt;just a example&lt;/p&gt;&lt;/div&gt; 7.标签名称和标签属性统一使用小写12345&lt;!-- bad --&gt;&lt;Div Id="test"&gt;&lt;/Div&gt; &lt;!-- good --&gt;&lt;div id="test"&gt;&lt;/div&gt; 8.建议的 html 脚手架(适合PC开发)12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta lang="zh"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"&gt; &lt;meta name="renderer" content="webkit"&gt; &lt;meta name="description" content=""&gt; &lt;meta name="keyword" content=""&gt; &lt;title&gt;Project Name&lt;/title&gt; &lt;link rel="stylesheet" href="example.css"&gt; &lt;/head&gt; &lt;body&gt; &lt;script src="example.js"&gt;&lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 属性规范1.属性引号用双引号12345&lt;!-- bad --&gt;&lt;link rel='stylesheet' href='example.css'&gt; &lt;!-- good --&gt;&lt;link rel="stylesheet" href="example.css"&gt; 2.Boolean 属性 Boolean 属性指不需要声明取值的属性。XHTML 需要每个属性声明取值，但是 HTML5 并不需要。 一个元素中 Boolean 属性的存在表示取值 true，不存在则表示取值 false。简而言之，尽量不要为 Boolean 属性添加取值。 1234567891011121314151617&lt;!-- bad --&gt;&lt;input type="text" disabled="disabled"&gt; &lt;input type="checkbox" value="1" checked="checked"&gt; &lt;select&gt; &lt;option value="1" selected="selected"&gt;1&lt;/option&gt;&lt;/select&gt; &lt;!-- good --&gt;&lt;input type="text" disabled&gt; &lt;input type="checkbox" value="1" checked&gt; &lt;select&gt; &lt;option value="1" selected&gt;1&lt;/option&gt;&lt;/select&gt; 3.自定义属性建议自定义属性必须以 data- 为前缀，便于阅读。 123456789&lt;!-- bad --&gt;&lt;a modal="toggle" href="#"&gt; Example link&lt;/a&gt; &lt;!-- good --&gt;&lt;a data-modal="toggle" href="#"&gt; Example link&lt;/a&gt; 4.属性顺序 HTML 属性应该按照特定的顺序出现以保证易读性，而且一致的属性顺序可能提升 1.5%的gzip 压缩率 class id, name data-* ... Classes 是为高可复用组件设计的，所以他们处在第一位。Ids 更加具体而且应该尽量少使用（例如, 页内书签），所以他们处在第二位。 12345678910111213&lt;!-- bad --&gt;&lt;a href="#" data-modal="toggle" id="... class="...""&gt; Example link&lt;/a&gt; &lt;input type="text" class="form-control"&gt; &lt;!-- good --&gt;&lt;a class="..." id="..." data-modal="toggle" href="#"&gt; Example link&lt;/a&gt; &lt;input class="form-control" type="text"&gt; 标签规范不要在自动闭合标签的结尾处使用斜线，如&lt;br&gt;、&lt;hr&gt;、&lt;input&gt;、&lt;meta&gt;、&lt;source&gt; 命名规范 对于需要自定义属性，属性名命名统一使用 data- 前缀，具体参考custom-data-attribute class 命名和 css 编码规范中的保持一致 id 命名，当作为 JS 钩子使用 时，以 J_ 为前缀，后面接大驼峰命名，且这类选择器不能出现在 css 中，例如 J_ExampleIdForJs。其他使用用法，例如充当锚点，label 对应 input 的 id，都正常默认使用即可。 多媒体兼容 为 img 标签添加 alt 属性以声明替代文本； 在多媒体标签内部提供指示浏览器不支持该标签的说明，如object、audio、video 123456789101112&lt;!-- bad --&gt;&lt;audio controls&gt; &lt;source src="horse.ogg" type="audio/ogg"&gt; &lt;source src="horse.mp3" type="audio/mpeg"&gt;&lt;/audio&gt; &lt;!-- good --&gt;&lt;audio controls&gt; &lt;source src="horse.ogg" type="audio/ogg"&gt; &lt;source src="horse.mp3" type="audio/mpeg"&gt; Your browser does not support the audio tag.&lt;/audio&gt; 注释规范由于 html 代码一般不会经过预处理，出于安全考虑，html 代码中不能出现任何关于业务相关敏感信息的注释。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web优化之离线化]]></title>
    <url>%2F2019%2F10%2F28%2Fweb%E4%BC%98%E5%8C%96%E4%B9%8B%E7%A6%BB%E7%BA%BF%E5%8C%96%2F</url>
    <content type="text"><![CDATA[写在前面现在混合开发的应用场景越来越多了.业内的解决方案也有很多,例:native + react-native的,支付宝或者微信的native + 小程序的.当然应用更多的还是native + webView这种场景.使用native + webView的优点很多: 开发方便 方便快速迭代 … 但是使用这套方案也有一个很致命的缺点:那就是很慢!,在native上点击了一个按钮触发一个打开webView的action操作,会经过以下几个过程: 初始化webview =&gt; 请求HTML,JS,CSS等静态资源 =&gt; 渲染模板 =&gt; 请求API 这中间的时间很久.经过测试我们项目在安卓低端机上表现为平均加载完成时间为4 ~ 5秒.这是非常难以接受的!所以优化的需求就迫在眉睫了. 优化的地方很多,本篇先介绍一下资源静态化! 使用静态化会将HTML和CSS以及JS保存在APP的沙盒中.当需要打开h5页面的时候直接从沙盒中通过file:读取,如此速度会大大提升!几乎可以做到近秒开.提升非常明显. 如何做?参见下面的2个流程图: APP启动流程图 APP中页面跳转流程图 注意事项:1. 登录态等数据存取使用cookie2. 外链必须注明请求协议.例:https:因为在内置包环境,打开html使用的是file:协议,故所有外链都必须写明资源协议,否则默认为file:.例: 12345//bad&lt;script src="//baidu.com/jquery.js"&gt;&lt;/script&gt;//good&lt;script src="https://baidu.com/jquery.js"&gt;&lt;/script&gt; 3. 页面跳转模块内的页面跳转使用vue-router来实现,此处不再赘述.而模块间的页面跳转则需要使用全路径.例: 1&lt;button @click="pushToOtherModule"&gt;跳转到其他模块&lt;/button&gt; 123456methods:&#123; pushToOtherModule()&#123; // pushToOtherModule window.location.href = "http://baidu.com/web/h5/other/index.html#/goods/1"; &#125;&#125; 4. 跨域使用file:协议加载html会导致跨域问题.该问题通过运维配置nginx已解决 5. 打包优化webpack的图片处理,字体处理,以及dllPlugin,treeshaking等此处不在赘述.具体参见官方文档. 名词解释1.内置包升级通过npm打包成zip包上传后台即可 2.开关通过开关可以方便控制APP走内置包还是走服务器,方便一键切换 3.白名单白名单的作用是用来映射URL,即当用户触发一个URL全链接跳转的请求时,APP会进行拦截.通过匹配白名单,即可知道目标页面是走内置包还是走HTTP请求. 大致的思路目前就是这样,实现起来也不是很难.对于性能提升却是质的飞跃,所以强烈推荐.此文档登录态维护在APP端,故登录态没有详述.这个也不难,读者自己思考即可.]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
      <tags>
        <tag>性能优化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Smartgit使用30天过期解决办法]]></title>
    <url>%2F2019%2F10%2F11%2FSmartgit%E4%BD%BF%E7%94%A830%E5%A4%A9%E8%BF%87%E6%9C%9F%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95%2F</url>
    <content type="text"><![CDATA[smartGit是一款git比较好用的GUI工具.未注册版本提供30天的试用期,提供一个过期了以后还可以使用的方法: 1.打开Finder 2.使用快捷键 command + shift + G 3.复制 ~/Library/Preferences/SmartGit/ 到输入框 4.点击确定调转到指定的文件夹删除settings.xml文件 至此,即可在30天的试用期到了以后继续使用了.当然最后还是要说一句,如果有条件,请支持正版. 提醒:最近smartGit有更新,发现本方法仅对版本低于:18.2.9 #13269有效.高版本暂不支持]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出react+redux之组件的生命周期]]></title>
    <url>%2F2019%2F08%2F23%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAreact-redux%E4%B9%8B%E7%BB%84%E4%BB%B6%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"></content>
      <categories>
        <category>react.js</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出react+redux之state和props]]></title>
    <url>%2F2019%2F08%2F22%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAreact-redux%E4%B9%8Bstate%E5%92%8Cprops%2F</url>
    <content type="text"><![CDATA[state 和 prop 差劲的程序员操心代码，优秀的程序员操心数据结构和它们之间的关系。 毫无疑问,在react中处理数据是需要我们多关心的事情.页面是由数据进行驱动的,那么如何科学,高效的处理数据则成为我们需要思考的问题. 在react中数据大体上分为两种: state state 是组件内部的状态 prop prop 是组件对外的接口 其实很简单,就一句话:state用来处理组件的内部状态,prop用来和外部组件进行交互 组件的props当我们初始化一个类组件的时候,在构造器中我们都会调用super(props)这个方法,那么为什么需要调用这个方法,如果不调用会导致什么结果的发生?可能很多人都没有仔细想过,因为基本上大多数的教程也都是让我们记住即可.今天我们讨论一下这个问题. 1234// 组件的构造函数(也可以称之为构造器)constructor(props)&#123; super(props);&#125; 这是因为:如果在构造函数中没有调用 super(props)，那么组件实例被构造之后，类实例的所有成员函数就无法通过this.props访问到父组件传递过来的props值. 而且还会直接报错,如下所示: 1ReferenceError: Must call super constructor in derived class before accessing 'this' or returning from derived constructor 还有一个要特别要注意的地方:决不能修改props! 2.1 设置prop的数据类型既然prop是组件对外暴露的接口,那么应该有一个接口规范来约束组件外传入的数据类型.这个propTypes就排上用场了,它的使用也很简单,首先导入,然后设置目标组件的propTypes就可以了,如下所示: 1234567891011121314import React,&#123; Component &#125; from 'react';import PropTypes from 'prop-types';class T extends Component&#123; constructor(props)&#123; super(props) &#125;&#125;/*这样就设置了T这个组件的prop的数据类型,name为字符串类型,并且是必传的.id是number类型,非必须*/T.propTypes = &#123; name:PropTypes.string.isRequired, id:PropTypes.number&#125; 注意:propTypes检查,仅限开发阶段,生产阶段需要剔除!生产阶段检查类型不但消耗资源,而且错误展示给用户也没有意义,故在生产阶段需要关闭propTypes检查,所幸我们可以使用babel-react-optimize来自动帮我们完成这个工作 2.2 设置prop的默认值这个就很容易理解了,给组件的prop设置一些默认值,当父组件没有传数据的时候会有一个默认值,哪些限制了isRequired的就不会报错了.还是上面的那个组件T.看下面的代码: 1234T.defaultProps = &#123; name:"allen", id:1&#125; 组件的state在react中驱动组件渲染过程的除了prop还有state.这一节我们就讲一下state.由于react不能修改prop,那么我们要记录组件自己的状态,就要使用state. 3.1 修改state的值react.js规定要修改state的值,必须使用setState({})来修改,不可以直接修改. 当然你非要直接修改,也是可以的.但是你会发现,直接修改值.页面并不会发生改变,这是因为直接赋值,虽然看起来你是修改了state中的值.但是并不会驱动页面的变化.这就是setState()帮我们做的一个事情,首先它会修改state中的值,然后它还会驱动组件的更新(执行render()方法) 3.2 使用场景我们已经知道了state的用途.在深入一下,什么时候该使用state什么时候需要使用类的属性?例如: 1234567constructor(props)&#123; super(props); this.state = &#123; list:[] //页面列表 &#125; this.sub = null; //订阅对象&#125; 其实很简单,一些状态的改变如果会导致页面的重新渲染,那么它就应该被定义在state中.如果某个字段不会导致页面的重新渲染,只是辅助我们开发,那么它就可以定义为这个类的一个属性. 区别说了这么多,现在总结一下区别吧: prop用户定义外部接口,state用于定义内部状态 prop不可修改,而state可以修改 prop赋值在外部,state在内部 var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-shenruqianchu-3-state-prop', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react.js</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出react+redux之jsx]]></title>
    <url>%2F2019%2F08%2F22%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAreact%2Bredux%E4%B9%8Bjsx%2F</url>
    <content type="text"><![CDATA[需求单独把JSX拿出来说一下,因为我觉得这个东西有必要深入研究一下.下面是我当时学习react.js的时候想到的几个问题: 为什么要在react.js中使用jsx? 将事件声明写在了JSX中是一种进步还是一种倒退? react.js是如何根据diff算法底层实现模板高性能重新渲染的?(因为我们知道每执行一次setState(),都会执行一次render()函数,react.js底层做了什么?它是如何优化的? 下面我们带着这几个问题,来深入研究一下什么是JSX. 1.JSXJSX是facebook推荐在开发react项目的时候替代HTML的写法,当然你也可以使用HTML,但是极度不推荐使用.下面我们看一个最简单的例子: 1234567891011121314151617181920212223import React,&#123; Component &#125; from 'react';import CustomComp from './CustomComp';class T extends Components&#123; constructor(props)&#123; super(props) &#125; render()&#123; return( &lt;div&gt; &#123;/*原生标签*/&#125; &lt;p&gt;我是原生组件&lt;/p&gt; &#123;/*react.js自定义组件*/&#125; &lt;CustomComp/&gt; &#123;/*定义一个事件*/&#125; &lt;button onClick=&#123;this.click&#125;&gt;BUTTON&lt;/button&gt; &lt;/div&gt; ) &#125; click()&#123; alert('btn did clicked!') &#125;&#125; 可以看到和我们之前写HTML大不同的地方就是react.js把HTML直接写在了js中.上面那个render()函数中包裹的就是JSX. 注意:在使用JSX的代码中必须导入React,也就是说第一行代码的import React,{ Component } from &#39;react&#39;虽然看起来在代码中我们没有使用React,但是它是很有用的.因为JSX会被转译成依赖react.js的表达式 2.分析为什么要在react中使用jsx?第一节我们已经知道了JSX是个什么东西,这一节我们分析一下为什么要在react.js中使用jsx.因为在react的设计思想中是all in js.所以我们如果在要在JS中写DOM的话,则需要创造一个一个的DOM对象.用JS来写，会非常的冗余并且不能一目了然的看清楚DOM的结构。所以这个时候JSX就诞生了! 思考一个问题：如何用JavaScript对象来表现一个DOM元素的结构，举个例子： 1234&lt;div class='box' id='content'&gt; &lt;div class='title'&gt;Hello&lt;/div&gt; &lt;button&gt;Click&lt;/button&gt;&lt;/div&gt; 每个 DOM 元素的结构都可以用 JavaScript 的对象来表示。你会发现一个 DOM 元素包含的信息其实只有三个：标签名，属性，子元素。 其实这个 DOM 结构我们是可以使用一个js对象来描述的,如下所示: 12345678910111213141516&#123; tag: 'div', attrs: &#123; className: 'box', id: 'content'&#125;, children: [ &#123; tag: 'div', arrts: &#123; className: 'title' &#125;, children: ['Hello'] &#125;, &#123; tag: 'button', attrs: null, children: ['Click'] &#125; ]&#125; 你会发现，HTML 的信息和 JavaScript 所包含的结构和信息其实是一样的，我们可以用 JavaScript 对象来描述所有能用 HTML 表示的 UI 信息。但是用 JavaScript 写起来太长了，结构看起来又不清晰，用 HTML 的方式写起来就方便很多了。 于是 React.js 就把 JavaScript 的语法扩展了一下，让 JavaScript 语言能够支持这种直接在 JavaScript 代码里面编写类似 HTML 标签结构的语法，这样写起来就方便很多了。编译的过程会把类似 HTML 的 JSX 结构转换成 JavaScript 的对象结构. 那么下面的这个代码: 123456789class Header extends Component &#123; render () &#123; return ( &lt;div&gt; &lt;h1 className='title'&gt;React 小书&lt;/h1&gt; &lt;/div&gt; ) &#125;&#125; 经过编译会变成: 123456789101112131415class Header extends Component &#123; render () &#123; return ( React.createElement( "div", null, React.createElement( "h1", &#123; className: 'title' &#125;, "React 小书" ) ) ) &#125;&#125; React.createElement 会构建一个 JavaScript 对象来描述你 HTML 结构的信息，包括标签名、属性、还有子元素等。这样的代码就是合法的 JavaScript代码了。所以使用 React 和 JSX 的时候一定要经过编译的过程。 这里再重复一遍：所谓的 JSX 其实就是 JavaScript 对象。每当在 JavaScript 代码中看到这种 JSX 结构的时候，脑子里面就可以自动做转化，这样对你理解 React.js 的组件写法很有好处。 有了这个表示 HTML 结构和信息的对象以后，就可以拿去构造真正的 DOM 元素，然后把这个 DOM 元素塞到页面上。这也是我们最后一段代码中 ReactDOM.render 所干的事情： 1234ReactDOM.render( &lt;Header /&gt;, document.getElementById('root')) ReactDOM.render 功能就是把组件渲染并且构造 DOM 树，然后插入到页面上某个特定的元素上（在这里是 id 为 root 的 div 元素）。 总结一下从JSX到页面都发生了什么? 有些同学可能会问，为什么不直接从 JSX 直接渲染构造 DOM 结构，而是要经过中间这么一层呢？ 第一个原因是，当我们拿到一个表示 UI 的结构和信息的对象以后，不一定会把元素渲染到浏览器的普通页面上，我们有可能把这个结构渲染到 canvas 上，或者是手机 App 上。所以这也是为什么会要把 react-dom 单独抽离出来的原因，可以想象有一个叫 react-canvas 可以帮我们把 UI 渲染到 canvas 上，或者是有一个叫 react-app 可以帮我们把它转换成原生的 App（实际上这玩意叫 ReactNative）。 第二个原因是，有了这样一个对象。当数据变化，需要更新组件的时候，就可以用比较快的算法操作这个 JavaScript 对象，而不用直接操作页面上的 DOM，这样可以尽量少的减少浏览器重排，极大地优化性能。这个在以后的章节中我们会提到。 总结为下面的几个点: JSX 是 JavaScript 语言的一种语法扩展，长得像 HTML，但并不是 HTML。 React.js 可以用 JSX 来描述你的组件长什么样的。 JSX 在编译的时候会变成相应的 JavaScript 对象描述。 react-dom 负责把这个用来描述 UI 信息的 JavaScript 对象变成 DOM 元素，并且渲染到页面上。 这里借鉴了react.js小书的部分内容,感谢作者的分享 3.在JSX中声明事件是进步还是倒退?讨论完了JSX底层如何进行处理的,现在我们讨论一下:使用JSX是进步还是倒退?尤其是当在JSX中需要给某个组件定义一个事件的时候. html 1&lt;button onclick="click"&gt;BUTTON&lt;/button&gt; react 12345render()&#123; return ( &lt;button onClick=&#123;()=&gt;alert('hello,react')&#125;&gt;BUTTON&lt;/button&gt; )&#125; 在以前我们所有接触到的知识都告诉我们,写web的时候要模板,样式及逻辑分离.不可以直接在html中定义事件.直到今天这个观点我们也不会改变,在html中使用onclick很不专业!(注意是onclick而非react.js中的onClick).主要是因为一下几个点: 在html中添加的onclick的事件处理函数是全局的,这样容易污染全局环境,导致一些不可预知的错误 给很多标签绑定事件,会导致性能问题.网页需要处理的事件函数越多,性能就越低 对于使用了onclick的DOM元素,如果要把它动态的从页面中删除掉,那么它的事件处理器也要被注销掉.否则会有导致内存泄露的BUG,而且这种BUG一般很难排查. 上述说的问题,在JSX中不存在! 首先,在JSX中声明的事件方法,仅在该组件内部有效.避免了污染全局环境 在JSX中所有的事件都委托给了顶层的DOM,当接收到用户的action的时候react.js会被顶层DOM的事件处理函数捕获,然后根据组件分发给不同的方法/函数.方法委托自然比一个一个事件绑定效率高 在react.js中组件存在声明周期,当组件被unmount的时候(也就是卸载/销毁)的时候,react.js会自动帮我们注销挂载在JSX上对应的事件处理方法.那么就不存在内存泄露的问题了. 3.虚拟DOM和diff算法这个稍微有些复杂,后面会再开一节进行详细说明 var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-shenruqianchu-2-jsx', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react.js</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出react+redux第一篇:基础篇]]></title>
    <url>%2F2019%2F08%2F22%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BAreact%2Bredux%E7%AC%AC%E4%B8%80%E7%AF%87%3A%E5%9F%BA%E7%A1%80%E7%AF%87%2F</url>
    <content type="text"><![CDATA[写在前面本篇连载是我学习react.js的一个笔记,之前一直保存在有道云笔记中,最近打算发到博客上面来. 1.环境配置首先我们需要下载react.js的一个官方的脚手架工具:create-react-app.终端执行下面的命令: 1npm install -g create-react-app 即可安装,然后终端中输入create-react-app -V,即可查看该脚手架的ban版本.目前最新版的是3.0.1. 脚手架已经安装完毕了,我们来创建一个react.js的应用吧. 12345678// 1.init projectcreate-react-app my-react-app// 2.cd cd my-react-app// 3.runnpm run start 2.浅尝组件现代前端开发开始流行一种开发思想叫做:组件式开发.不论是vue.js,anglar.js亦或者是我们今天要学习的react.js都是倡导组件式开发,所谓组件式开发即是把一个项目认为是一棵组件树,而每一个页面/模块都是该组件树的一个分支,该分支上的页面又可以拆分为不同的小组件,各个组件堆砌组合成为了一个功能完整的页面乃至应用. 一个最简单的react.js的组件如下所示: 123456789101112131415161718192021222324252627import React,&#123; Component &#125; from 'react';class MyComponent extends Component&#123; constructor(props)&#123; super(props) this.state = &#123; name:'hello,world' &#125; this.btnDidClick = this.btnDidClick.bind(this); &#125; render()&#123; return( &lt;div&gt; &lt;p&gt;我是一个最基础的react.js组件&lt;/p&gt; &lt;div&gt; &lt;p&gt;&#123;this.state.name&#125;&lt;/p&gt; &lt;button onClick=&#123;this.btnDidClick&#125;&gt;点我&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ) &#125; btnDidClick()&#123; this.setState(&#123; name:'hello,react.js' &#125;) &#125;&#125; 可以看到定义一个组件是一件很简单的事情,这里细心的朋友应该发现了一个问题:我们导入了import React,{ Component } from &#39;react&#39;;,在代码中我们定义的类继承自Component这个基类.但是React好像并没有用?那是不是可以不用导入? 尝试删除React,发现报错了! 1&apos;React&apos; must be in scope when using JSX react/react-in-jsx-scope 报错信息是指在使用JSX的范围内,必须要有React!所以,记住:当我们使用JSX的时候必须导入React! var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-shenruqianchu-1-rumen', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react.js</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native屏幕适配]]></title>
    <url>%2F2019%2F08%2F09%2Freact-native%E5%B1%8F%E5%B9%95%E9%80%82%E9%85%8D%2F</url>
    <content type="text"><![CDATA[1.写在前面在使用react-native进行开发的时候我们参见官方文知道做屏幕适配是使用flexBox来进行布局. 戳我查看flexBox布局 有关flexBox的属性这里不做太多介绍,不会的请参考官方文档.这里只是说一下,因为在做屏幕适配的时候的解决之道. 在react-native中我们使用StyleSheet这个对象来进行样式的开发.例如: 123456789101112131415import &#123; StyleSheet &#125; from 'react-native';// 声明了一个style的变量,使用它来给组件添加样式let style = StyleSheet.crate(&#123; title:&#123; fontSize:14, color:"#BBB" &#125;, subTitle:&#123; marginTop:10, marginBottom:10, paddingLeft:10, paddingRight:10 &#125;&#125;) 可以看到在react-native中写样式和在web中写CSS还是有很大的区别的.哪些好用的less,sass等基本上不可以用.而且也不可以用复合样式.例如: web中写样式 1234/* web */.title&#123; padding:10 20 15 5;&#125; react-native中写样式 1234567/* react-native */title:&#123; paddingTop:10, paddingRight:20, paddingBottom:15, paddingLeft:5&#125; 可以看到在rn中写样式还是比较麻烦的. 2.使用flexbox布局flexBox给我们提供了很方便的布局方法,但是有时候我们还是需要一些常规属性,例如:width,height,paddingTop,fontSize等等…因为在rn中样式是没有单位的(默认dp),那么这个时候问题就来了,在不同的屏幕上它的dpi是不同的,如何做适配呢? 通过查看官方文档,找到了解决方法.封装了一个方法dp2px,代码如下所示: 12345678import &#123; Dimensions &#125; from "react-native";const deviceWidthDp = Dimensions.get("window").width;// 默认设计稿375const uiWidthPx = 375;function dp2px(uiElementPx) &#123; return (uiElementPx * deviceWidthDp) / uiWidthPx;&#125;export default dp2px; 这样在开发中如果需要使用一些宽度,高度等属性的时候直接引用这个方法就可以了.如下所示: 12345678import dp2px from './dp2px';title:&#123; paddingTop:dp2px(10), paddingRight:dp2px(20), paddingBottom:dp2px(15), paddingLeft:dp2px(5)&#125; 这样就完成了适配的工作.但是这个就是最优解了么,显然不是.每次写样式的都需要把这个函数引用进来,而且每次都要写大量的dp2xp,实在是非常的麻烦.那么问题来了,我们如何优化? 3.封装CustomStyleSheet代替原生StyleSheet通过翻看源码,发现StyleSheet不是一个类,我们不需要继承它,重写它的这个方法,只需要自己封装一个类似StyleSheet这样的一个函数在它的内部进行一些计算,然后在需要写样式的地方,统一使用我们的CustomStyleSheet代替原生的StyleSheet即可.代码如下所示: 123456789101112131415161718192021222324252627282930313233343536373839import &#123; StyleSheet &#125; from "react-native";import dp2px from "./dp2px";let MyStyleSheet = &#123; create(style) &#123; let s = &#123; ...style &#125;; // 目前仅对以下的属性进行处理 let list = [ "width", "height", "marginTop", "marginBottom", "marginLeft", "marginRight", "paddingTop", "paddingRight", "paddingBottom", "paddingLeft", "top", "right", "bottom", "left", "fontSize", "lineHeight" ]; for (outKey in s) &#123; for (innerKey in s[outKey]) &#123; if ( list.includes(innerKey) &amp;&amp; typeof s[outKey][innerKey] == "number" ) &#123; s[outKey][innerKey] = px2dp(s[outKey][innerKey]); &#125; &#125; &#125; return StyleSheet.create(s); &#125;&#125;;export default MyStyleSheet; 通过上述封装后使用起来就很方便了.在react-native组件中直接使用它来代替原生的StyleSheet即可.例如: 123456789101112131415import MyStyleSheet from './myStyleSheet';// 使用封装好的MyStyleSheet来代替原生StyleSheet,直接写数字即可自动转换为不同屏幕适配的dplet style = MyStyleSheet.create(&#123; title:&#123; fontSize:14, width:100 &#125;, subTitle:&#123; paddingTop:10, paddingBottom:10, marginTop:10, marginBottom:10 &#125;&#125;) 至此,结束.附上相关资料,供学习. 参考资料: 阮一峰的Flex教程 var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-native-r14i', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[新建CustomStyleSheet废弃StyleSheet]]></title>
    <url>%2F2019%2F08%2F08%2F%E6%96%B0%E5%BB%BACustomStyleSheet%E5%BA%9F%E5%BC%83StyleSheet%2F</url>
    <content type="text"><![CDATA[本来打算新开一篇文章写这个的,但是因为本人懒得写,算了.参见本人的另一个博客,写在了这里: react-native屏幕适配,可能是比较好的解决方案 that’s all var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-native-x28t', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改react-native组件的默认属性]]></title>
    <url>%2F2019%2F08%2F08%2F%E4%BF%AE%E6%94%B9react-native%E7%BB%84%E4%BB%B6%E7%9A%84%E9%BB%98%E8%AE%A4%E5%B1%9E%E6%80%A7%2F</url>
    <content type="text"><![CDATA[问题我们在做网页开发的时候知道标签有自己的默认样式,例如&lt;ul/&gt;,&lt;li/&gt;等等.所以一般我们在开发项目的时候首先要做的就是先把标签的默认样式给清除掉.在开发RN的时候发现有些组件的默认属性很烦人.同样的需要重写这些默认属性.例如: 12&lt;Text/&gt;&lt;TextInput/&gt; 这两个组件的allowFontScaling=true即:属性默认跟随系统字体大小,超级坑爹. 还有这个组件: 1&lt;TouchableOpacity/&gt; 这个组件默认点击的时候会有一个阴影效果,因为它的默认透明度是0.2. 这些默认属性有时候会给我们带来很大的困扰,有些组件的属性默认值并不是我们想要的.那么该怎么做呢?在每次使用这个组件的时候手动修改该组件的属性值? 这样做可以满足需求,但是太蠢了.每次使用上述组件的时候都要修改某些属性值.太蠢.这个方法舍弃. 解决之道: 在开发web的时候我们可以修改标签属性的默认值,比较常用的有:reset.css或者normalize.css.那么在开发RN的时候我们可以修改组件的属性的默认值吗?答案是当然可以的啦.通过查看源码发现通过如下修改,即可覆写react-native的原生组件的属性的默认值: 新建一个JS文件,代码如下所示: 1234567891011121314151617import &#123; Text, TextInput, TouchableOpacity &#125; from "react-native";/** * 说明:此文件为修改React-native的原生组件的一些默认属性配置 * 1.修改Text和TextInput的属性,字体大小不跟随系统设置 * 2.修改TouchableOpacity的默认属性0.2 =&gt; 1(即去除该组件默认的按下去的阴影效果 =&gt; 点击的时候按下去没有阴影效果) */TextInput.defaultProps = Object.assign(&#123;&#125;, TextInput.defaultProps, &#123; allowFontScaling: false&#125;);Text.defaultProps = Object.assign(&#123;&#125;, Text.defaultProps, &#123; allowFontScaling: false&#125;);TouchableOpacity.defaultProps = Object.assign( &#123;&#125;, TouchableOpacity.defaultProps, &#123; activeOpacity: 1 &#125;); 这里修改了3个常用组件的默认值 2.在RN项目的入口处导入即可.我是在index.js中导入. 12// in index.js`import './customComponentsConfig.js'` 通过上述操作,即可重写掉react-native中组件的默认属性值.以上只是举例,根据自己的需求扩展即可.如果有问题,请翻看源码. var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-native-x21g', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native混合开发之热更新的实现]]></title>
    <url>%2F2019%2F08%2F01%2Freact-native%E6%B7%B7%E5%90%88%E5%BC%80%E5%8F%91%E4%B9%8B%E7%83%AD%E6%9B%B4%E6%96%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[前言react-native可以独立写APP,但是在更多的公司中以混合开发模式居多.也就是说部分模块使用native去开发,部分模块使用react-native来进行开发.这种开发模式带来的优点是显而易见的,native+react-native可以在处理某些更新频繁,突发性需求或者对Ui页面灵活性要求比较高的地方.例如618,双11,双12…这种页面通常都有具有很大的灵活性.如果这个时候我们都用native来实现则灵活性欠佳.而使用native+react-native的混合开发模式则可以完美的解决这个问题.静默升级,用户体验佳.且iOS不用发版,不用提交审即可更新,大大的提高了产品的迭代速度,为用户带来更好的体验 1.HOW具体怎么做呢?首先当然是我们需要打包各平台对应的bundle包.如何打包,参见上一篇文章:react-native优化之拆包.下面的是已经打包好的图示: iOS android 可以看到针对ios和android两个平台我们都已经打包出来的各自的bundle包和静态资源. 这里对文件做一下解释说明: base.bundle这个是项目中的基础包,也是上面所说的react-native优化之拆包中的基础包.此包中包含react的一些基础依赖,例如:react,react-native,react-navigation,redux等底层基础依赖 bus.bundle则是业务包.它是动态的,会升级的比较频繁.一般基础包会持久化在APP的沙盒中,基本上处于静止状态,不做更新,除非有大的版本更新,才做基础包更新. assets这个是iOS平台依赖的图片静态资源.内含在react-native中使用的@2x图和@3x图 drawable-xhdpi和drawable-xxhdpi这个是安卓平台依赖的图片资源 在实际应用中我们一般会将bus.bundle和assets或者drawable-xhdpi(drawable-xxhdpi)打包成为一个ZIP,一来这样体积更小,在APP上下载也更快,二来这样可以把bundle和静态资源打包到一起,更新的时候直接下载这个ZIP,解压缩即可 问题这样其实就完成了react-native在iOS和android中的热更新.但是理想是美好的,现实是残酷的.这里把我踩到的坑分享一下 iOSiOS接入很正常没有问题,没有任何毛病.按照上面所述直接接入就可以了,比较简单 Android安卓有坑!而且这个坑很大!网上资料比较少.当时做rn拆包的时候参考官方文档的打包代码如下所示: 1node ./node_modules/react-native/local-cli/cli.js bundle --platform android --dev false --entry-file index.js --bundle-output ./release-android/myCenter.bundle --assets-dest ./release-android/ --config bus.config.js 这个时候我把bundle和静态资源(图片)放在了安卓的: 1android =&gt; app =&gt; src =&gt; main =&gt; assets =&gt; rn(新建的) 一切都看起来这么顺利这么美好,跑起来瞅瞅:发现问题:所有的图片都不展示! 经过各种翻看文档,发现要把图片解压缩在:android =&gt; app =&gt; src =&gt; main =&gt; res =&gt; drawable-xhdpi或者drawable-xxhdpi里.遂尝试之.重新跑一下,成功显示! 遂告诉android开发只需要执行下载更新的时候把zip下载完毕了以后把图片解压缩到这个目录里面问题就解决了!然而安卓开发给我反馈了一个令人沮丧的消息,这个目录是只读的!Excuse Me!!!只读,特么的逗我? 没想到这个方案也不行,真是坑爹啊!react-native官网也不见有提示说混合开发的图片资源放哪里啊.这可咋整!吐槽完毕之后问题还是要解决的,经过不懈的各种查看文档,到处google,stackoverflow冲浪,终于功夫不费有心人,找到了解决方案:安卓需要把更新包解压缩至sdcard这个目录里!!! 热更新终极解决方案踩了这么多的坑,热更新的解决方案终于落地了: 安卓接入react-native的初始版本安卓会将基础包和业务包放在assets中.然后当服务器上有ZIP的更新的时候会静默自动下载ZIP包,解压缩至sdcard这个目录里.缓存起来.以后每次启动的时候就直接加载sdcard中的bundle.至此即完成了混合开发中安卓端的热更新. 而iOS则就比较简单了,看上面所述即可.直接解压缩到沙盒目录中即可.当然肯定不能放到可以被用户手动清除到的地方.例如:cache目录. 至此:react-native的混合开发之热更新就解决完毕了.有什么问题可以留言或者给我发邮件都可以. 参考资料:混合开发是如何实现热更新的react-native热更新实现 var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-native-r20n', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xcode官方下载地址,可用迅雷下载]]></title>
    <url>%2F2019%2F07%2F31%2Fxcode%E5%AE%98%E6%96%B9%E4%B8%8B%E8%BD%BD%E5%9C%B0%E5%9D%80-%E5%8F%AF%E7%94%A8%E8%BF%85%E9%9B%B7%E4%B8%8B%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[在国内网络情况令人窒息,有需要更新xcode的时候在appStore上下载就非常的慢,下面是xcode的官方下载地址: 戳我使用迅雷下载xcode mark一下,以备不时之需. var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'ios-x16i', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native打包安卓的一个坑]]></title>
    <url>%2F2019%2F07%2F29%2Freact-native%E6%89%93%E5%8C%85%E5%AE%89%E5%8D%93%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91%2F</url>
    <content type="text"><![CDATA[写在前面如果你在做一个混合开发的APP,也就是说部分模块使用native去开发,部分模块使用react-native去开发.这个时候如何使用图片资源就有的玩了.如何合理的使用图片资源也是一个问题. 引申:在react-native中如何使用图片资源 根据官方文档所述:在react-native中使用image的话有几种方法: 1.使用APP中的图片资源也就是说在JS中直接访问APP沙盒中存在的图片资源,iOS加载assets目录,安卓加载drawable目录.代码如下所示: 1&lt;Image source=&#123;&#123;uri:'test_img'&#125;&#125; style=&#123;&#123;width:100,height:100&#125;&#125;&gt; 使用这个方法加载图片资源的话不需要写后缀,但是!你必须要确保这个图片在APP的沙盒内部是一定存在的!react-native不会检查这个文件是否存在如果不存在则出现一个空白. 2.使用网络图片这个就很简单了,看下面的代码: 12&lt;Image source=&#123;&#123;uri: 'https://facebook.github.io/react/logo-og.png'&#125;&#125; style=&#123;&#123;width: 400, height: 400&#125;&#125; /&gt; 注意:iOS因为从iOS8开始只能使用https了,所以这里建议网络图片全部使用https,并且需要指定尺寸. 3.使用base64 在react-native中是可以使用base64的图片的,在想目中一些icon你可以选择使用iconFont也可以选择使用base64.使用base64也很简单,找个在线转码的网站,把你需要转的图片转成base64就可以了.在代码中这样使用: 1&lt;Image source=&#123;&#123;uri:"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAD8AAAA/CAYAAABXXxDfAAAD0ElEQVR4Ae2aA5A8VxDGO7Ztv57D65mLbZvd7xjbRunv2LZt2045KsS27aSDvT7PZg87e+9X1aVbfY/f13MwWohEIpFIJBKJJL7VO+KJ6OU65/mOohWS3ILEZ9elYas//vhjMshDw3ZjpnYUJjniX53nP2qh0PMjSO2LwUCg58vtG2toAD5Ilu+YA/rCZbxllzcRX5IQb5Y0Na80JJWFlYeqMOW1XCpHOC9fdeqRq/uZdXmyNFJpGA81QB3J0kjy83+6GpcLC0F39FAwL/o9y3aYFWoEJLnnP/FJKltDd3CVnWYy++NTUGpH/FklbRR27l88ySc1Jv5Ms+93ieKj+Cg+94FX++K10MvDLpPloOCoLvX5ucWb+h1JrlxzzR2mhYKhXh5JLnOef1Qt/Ypfc80xUyLJ/ioWib/rNgh3LLPMblNBThrW3GvGhMJRSHJKxZXKsXUkjWUJ97KF8/KD1dCveIsGACS+1b4Jia+HnGgqHNxgIq9CTtTEdE+kSPJC4uVo58OBSG0IeUhSPrjbj9go5wFz6OAmMnku1++l5u27/d6X60hWhP+LJiGzZJ6BHGhO0DSos1BpuTS09xlFDdgU5jcJTuuOlVY6cDqoBKL2udHzZ6VgkIU1q7PzJCfaGV9hhdaZB+uePKVz9sMkqDL0sHbEX5jktikMFhoDzcF3axVm9hXNrL82ZsyYyWGw0K6LEf84VBmYhp1M9+mqwR3ZrHk9c23cU3XiPR9mxE+EwUTvR7OszoUqw/mwd+d+5zNgMNErriQ+De1QZaijM1fcfTBY6F1rltRHf9nc6aHKUB+gOeTfbfmz3vlQKdrpRC+fl5YUhUMgJy5tXhU9H4PEx1dSiQ+75Tm9kfhBY8ZOqHDGmzd0xB+bjP/WgLNuEyLx94NlbxNqboYBUOvdNY2GzaEcNLpixqug5wv1A+zTjrqsZamyPsfzp4Mlvi4Lm+Q0YzeYW+lb9fq5Y6hNQ3af16fNDVAm3rcsrvExSWX3Sgqpee0yvnM2ffDSLY3erSbN9iRyNDPkByQ5Tj8QCoRuTQ01vTVmNPjoFhqoh/dNwzIdC0PxsF5/oj13Rl33tm6Ztvm0J4HEr4/a1rW6vig+io/ie/4vjjkVf7St6qJj+5CYSWtfFvHtTkvJm0Hx0Xt/Fuflw/909dnN1UBgnV1dxhvbUFE01GXawIMkb/SpRy2uvqBbw/9bR/xOAevj7g5vQKvckLYsb5Z/TZRmfDU7ufeJPtbVLF9s0fyL83J/Q9aSgSXvk5emph3nUp9ftNJujr2xIpFIJBKJREYNfwIbCE1RyoFBpwAAAABJRU5ErkJggg=="&#125;&#125; style=&#123;&#123;width:100,height:100&#125;&#125;&gt; 这种方式仅适合一些小图,例如一些icon之类的.同样需要指定图片的尺寸 4.使用js自己的图片资源把图片放在某处,使用require关键字来引用,如下所示: 1&lt;Image source=&#123;require('./my-icon.png')&#125; /&gt; 说了这么多,其实在项目中我们使用的方法是:小图使用base64+大图使用网络图片或者本地图片资源.这样做的有什么好处呢?因为项目是混合开发的一个项目,所以如果要做新模块的话,那么图片一般不会已经存在于APP的沙盒中,这就需要我们自己提供图片资源了.而且这样也比较好解耦,APP只需要下载我们的zip包.并且解压缩出来bundle包和图片资源即可完成静默升级. 继续:之前有写过一个react-native拆包的文章,上次打包的时候在使用了命令: 1node ./node_modules/react-native/local-cli/cli.js bundle --platform ios --dev false --entry-file index.js --bundle-output ./release-ios/myCenter.bundle --assets-dest ./release-ios/ --config bus.config.js 打出来的业务包的bundle和业务中的图片资源都在realease-ios目录下面,然后在iOS中直接把这个目标文件夹放在任何一个路径下面都是可以直接加载到的. BUT:问题来了!执行了打包方法之后打包出来的安卓bundle以及图片资源.图片在安卓上面无法展示!!! 经过查看react-native的文档以及各种google和stack-overflow终于找到了问题,原来打包出来的图片资源只能放在安卓的特定的目录下面:这个目录如下所示: 1andorid -&gt; app -&gt; src -&gt; main -&gt; res -&gt; drawable-xhdpi/drawable-xxhdpi(对应的尺寸解压缩到同名的文件夹里) 这样就解决了混合APP中安卓无法加载bundle包中的图片资源. var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-native-r18g', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native-swiper的一个坑]]></title>
    <url>%2F2019%2F07%2F25%2Freact-native-swiper%E7%9A%84%E4%B8%80%E4%B8%AA%E5%9D%91%2F</url>
    <content type="text"><![CDATA[问题项目有个需求是轮播,纵向滚动.遂在github上找到了一个star比较多的插件:react-native-swiper.接入的也是很方便的,美滋滋.然后想目跑起来,xcode开起来,没毛病,挺好. 继续打开项目,在android环境下跑一跑,没想到出问题了,纵向滚动不生效. 遂上github看issues发现很多人都遇到了这个问题,这个组件纵向滚动的时候在iOS平台是没有问题的,但是在安卓下面都遇到这个问题,不能纵向滚动,只能横向滚动! 继续查看资料发现是react-native-swiper - 1.5.14版本存在的这个问题.解决这个问题需要切换到react-native-swiper - 1.5.13即可解决,或者使用另外一个库:@nart/react-native-swiper.这个库其实是基于react-native-swiper - 1.5.13的,使用这个库即可解决这个问题. 12345// step 1,安装npm i @nart/react-native-swiper --save// step 2,在代码中引用import Swiper from '@nart/react-native-swiper'; var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-native-r21g', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown快速入门]]></title>
    <url>%2F2019%2F07%2F23%2Fmarkdown%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[Markdown是一种纯文本格式的标记语言。通过简单的标记语法，它可以使普通文本内容具有一定的格式.他有很多优点: 只要是支持markdown语法的编辑器都可以直接拿来写文章,很方便 通过使用一些简单的语法就可以实现很好看的排版,还是很不错的 markdown语法上手很简单,五分钟学会 很多在线写作平台都支持markdown 最后一点:特别适合程序员写博客! 下面简单学习一下markdown几个常用的语法 1.标题在想要设置为标题的文字前面加#来表示:一个#是一级标题，二个#是二级标题，以此类推。支持六级标题。 12345# 1级标题## 2级标题### 3级标题#### 4级标题##### 5级标题 1级标题2级标题3级标题4级标题5级标题 2.字体 两个星号包住就是加粗 一个星号包住就是斜体 三个星号包住就是加粗斜体 两个波浪号包住就是删除线 1234**这是加粗的文字***这是倾斜的文字*`***这是斜体加粗的文字***~~这是加删除线的文字~~ 效果如下所示: 这是加粗的文字这是倾斜的文字这是斜体加粗的文字这是加删除线的文字 3.引用在需要引用的文字前面加上&gt;就可以了 1&gt;加班还是不加班,这是一个问题 -鲁迅 效果: 加班还是不加班,这是一个问题. -鲁迅 (鲁迅表示这话我没说过…Orz…) 4.分割线使用三个星号或者三个横杠都可以实现, 123华丽丽的分割线:---*** 效果: 5.图片1![图标的ALT](图片的URL,图片的TITLE) 效果: 6.超链接超链接和图片很类似,就是没有开头的!(感叹号) 1[百度一下,你就知道](https://baidu.com) 效果: 百度一下,你就知道 7.列表列表分为有序列表和无序列表: 12345678910- 1.item1 - item1-1 - item1-1-1 - item1-1-1-1- 2.item2 - item2-1 - item2-2 - item2-2-1- item1 效果: 有序列表: 1.item1 item1-1 item1-1-1 item1-1-1-1 2.item2 item2-1 item2-2 item2-2-1 无序列表: item1 item1-1 建议列表不要嵌套的太深. 8.表格表格也是很常用的一个语法,形如 1234TITLE|DESC--|--姓名|allenliu性别|男 效果: TITLE DESC 姓名 allenliu 性别 男 9.字符高亮使用键盘esc下面的反点(名称叫做:间隔符)来包裹 1`高亮的文本` 效果: HELLO,markdown! 10.代码块下面是大杀器,对于程序员来说非常好用的一个东西,就是代码块.使用三个间隔符和要包裹代码的语言开始,以三个间隔符结尾.中间塞入你的代码: 形如: 效果: 123&lt;div&gt; &lt;p&gt;hello,markdown!&lt;/p&gt;&lt;/div&gt; 1console.log('awsome markdown!'); 123.p&#123; color:'red'&#125; 上面就是markdown最高频的语法了,当然还有很多高级用法,例如:流程图,甘特图,数学公式等等高级功能,但是这些因为平时不是很常用,需要的时候查一下就可以了. 查询更多markdown高级用法,戳这里 var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'markdown-m10n', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>markdown</category>
      </categories>
      <tags>
        <tag>markdown</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native在安卓手机运行起来一片空白,为何?]]></title>
    <url>%2F2019%2F07%2F22%2Freact-native%E5%9C%A8%E5%AE%89%E5%8D%93%E6%89%8B%E6%9C%BA%E8%BF%90%E8%A1%8C%E8%B5%B7%E6%9D%A5%E4%B8%80%E7%89%87%E7%A9%BA%E7%99%BD-%E4%B8%BA%E4%BD%95%2F</url>
    <content type="text"><![CDATA[问题今天在搭react-native的android开发环境,JDK,android-studio等一堆东西配好了以后.android-studio连上我的大华为手机,本地的rn服务已经成功启动.然后打开APP以后,进入rn调试页面,WTF???一片空白… 看了下终端是没有任何报错的,android-studio也是编译通过了,没有任何报错,为啥一片空白? 关掉真机,启动卡如狗的安卓模拟器,发现在模拟器里是可以正常展示的.那么问题来了?为啥模拟器可以真机不行?真机哪里出现了问题? 经过google,stack-overflow多方查阅后知道,解决方案如下所示: 设置 -&gt; APP -&gt; 权限管理 -&gt; 悬浮框权限(开启) 手机需要和电脑在一个WIFI网络下,或者挂代理 真是一个坑啊,至此:react-native的项目应该在安卓真机上可以正常的显示了. 2019/07/24 补充: 今天下午开会提到了这个问题,如果生产环境还是这样那岂不是炸了,用户是不可能会主动打开悬浮窗的权限的.后来安卓小伙伴补充到:原来这个问题只会在dev环境中出现,等上生产环境了以后,直接加载bundle包是不会有这个问题的.Thank godness! var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-native-r24e', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mac环境下配置jdk]]></title>
    <url>%2F2019%2F07%2F19%2Fmac%E7%8E%AF%E5%A2%83%E4%B8%8B%E9%85%8D%E7%BD%AEjdk%2F</url>
    <content type="text"><![CDATA[需求开发react-native需要配置安卓开发环境,所以我们需要安装javaJDK以及配置相关的环境变量,网上window的配置教程居多,这里是一个简单的mac版的jdk配置流程,仅供参考. 1.配置java开发环境下载对应平台的jdk,去oracle官网即可下载:戳我去下载JDK 2.安装JDK安装下载的JDK,等待安装完毕以后,打开终端,输入: 1java -version 如果出现下所示,就说明JDK已经安装成功了! 123java version "12.0.2" 2019-07-16Java(TM) SE Runtime Environment (build 12.0.2+10)Java HotSpot(TM) 64-Bit Server VM (build 12.0.2+10, mixed mode, sharing) 安装完毕以后就可以在/Library/Java/JavaVirtualMachines这里找到刚才安装的JDK,其中Contents下的Home文件夹，是该JDK的根目录 3.配置环境变量3.1 打开终端,如果你是第一次配置环境变量，可以使用touch .bash_profile创建一个.bash_profile的隐藏配置文件(如果你是为编辑已存在的配置文件，则使用open -e .bash_profile命令)3.2新建了.bash_profile隐藏文件,以后执行命令open -e .bash_profile打开这个配置文件3.3输入以下配置123456JAVA_HOME=/Library/Java/JavaVirtualMachines/jdk1.8.0_40.jdk/Contents/HomePATH=$JAVA_HOME/bin:$PATH:.CLASSPATH=$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:.export JAVA_HOMEexport PATHexport CLASSPATH 注意:上面的JAVA_HOME是你JDK安装的home路径,这里需要修改为你本机的JDK-&gt;home路径然后保存,关闭窗口即可. 3.4 执行命令source .bash_profile使配置生效3.5 输入 echo $JAVA_HOME 显示刚才配置的路径,如下所示:1/Library/Java/JavaVirtualMachines/jdk-12.0.2.jdk/Contents/Home 至此,我们就完成了JDK的安装和环境变量的配置. var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-native-m9k', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native优化之拆包]]></title>
    <url>%2F2019%2F07%2F18%2Freact-native%E4%BC%98%E5%8C%96%E4%B9%8B%E6%8B%86%E5%8C%85%2F</url>
    <content type="text"><![CDATA[react-native优化在做react-native var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-native-r15o', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react-native字体大小不随系统字体大小同步改变]]></title>
    <url>%2F2019%2F07%2F18%2Freact-native%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E4%B8%8D%E9%9A%8F%E7%B3%BB%E7%BB%9F%E5%AD%97%E4%BD%93%E5%A4%A7%E5%B0%8F%E5%90%8C%E6%AD%A5%E6%94%B9%E5%8F%98%2F</url>
    <content type="text"><![CDATA[问题最近在做react-native的开发,昨天项目提测了以后没想到在测试人员的测试手机上直接炸了!好几台手机都显示异常,iPhone7,iPhoneX,iPhoneX Max均出现字体变大,样式乱套的问题. 惊了!但是很纳闷在我的手机和模拟器都是没有问题的,遂查看测试的手机发现该测试人员均修改了几台测试手机的系统字体(修改步骤:设置 -&gt; 显示与亮度 -&gt; 字体大小),几台测试机的字体均被不同程度放大!这个就是问题的根源! 原来在react-native中Text和TextInput组件的字体大小会默认跟随系统的字体大小! 解决之道既然我们知道了导致这个问题的所在原因,那么就着手解决掉就可以了.经过查react-native的官方文档得知:在react-native中用来显示文字的，一般会用到两个组件：Text和TextInput。所以，我们只要针对这两个组件做好工作，那就基本上解决了字体大小适配的问题 而他们两个有个共同的属性allowFontScaling,这个属性的值模式是true,这个属性是什么意思呢? 是否随系统指定的文字大小变化而变化。默认值为true 解决方法一:设置allowFontScaling属性为false123// 设置该属性为false&lt;Text allowFontScaling=&#123;false&#125;/&gt;&lt;TextInput allowFontScaling=&#123;false&#125;/&gt; 但是这个方法有个弊端,也就是说在每次使用Text,TextInput组件的时候都要设置这个属性为false,有点麻烦,万一那次不小心忘了.就又炸了. 解决方法二:封装原生Text和TextInput组件每次使用Text或者TextInput组件的时候都要设置这个属性为false好烦,那么我们不禁会想到自己封装一个公共组件,如下所示: 123456789101112131415import React from 'react'import &#123;Text&#125; from 'react-native'export default class MyText extends React.Component &#123; // 封装react-native原生组件为MyText render() &#123; return ( &lt;Text allowFontScaling=&#123;false&#125; &#123;...this.props&#125;&gt; &#123;this.props.children&#125; &lt;/Text&gt; ) &#125;&#125; TextInput组件同理 这样每次在使用Text组件的时候就使用封装好的MyText就行了,这个问题也就解决了.但是,这不是更麻烦吗?每次使用的时候还需要导入这个组件,万一忘了就又炸了!这个方案PASS! 解决方案三:修改组件的defaultProps翻看一下组件的源码: TextInput 12345678... getDefaultProps(): Object &#123; return &#123; allowFontScaling: true, underlineColorAndroid: 'transparent', &#125;; &#125;,... Text 1234567... static defaultProps = &#123; accessible: true, allowFontScaling: true, ellipsizeMode: 'tail', &#125;;... 通过这两个代码片段可以知道，在定义Text和TextInput时，都有给组件设置默认属性的操作.那么就有解决方案就有了: 12TextInput.defaultProps = Object.assign(&#123;&#125;, TextInput.defaultProps, &#123;defaultProps: false&#125;)Text.defaultProps = Object.assign(&#123;&#125;, Text.defaultProps, &#123;allowFontScaling: false&#125;) 切记这段代码要写在你react-native的入口处,我写在了index.js里面.使用该方法真正实现了一劳永逸,所以这个方法是最方便的. var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-native-r25n', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react-native</category>
      </categories>
      <tags>
        <tag>react-native</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react官方文档学习笔记]]></title>
    <url>%2F2019%2F07%2F09%2Freact%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[函数组件和class组件在react中组件分为函数组件和class组件,他们是有区别的,并不是说任何时候都可以用class组件. 函数组件 1234// 定义一个函数组件function welcome(props)&#123; return &lt;div&gt;&#123;props.name&#125;&lt;/div&gt;&#125; 该函数是一个有效的React组件，因为它接收唯一带有数据的props（代表属性）对象与并返回一个React元素。这类组件被称为函数组件，因为它本质上就是JavaScript 函数。 class 组件 123456// 定义一个class组件class Welcome extends React.Component&#123; render()&#123; return &lt;div&gt;&#123;this.props.name&#125;&lt;/div&gt; &#125;&#125; 上述两个组件在react中其实是等价的,但是不是相同的.class组件会有一些额外的特性.这个在后面会仔细分析. 注意!在react中所有的组件都必须大写字母开头 React 会将以小写字母开头的组件视为原生 DOM 标签。例如，&lt;div /&gt;代表 HTML 的 div 标签，而 则代表一个组件，并且需在作用域内使用 Welcome。 组件嵌套其实就是自定义的组件是可以随意嵌套的,这里不在赘述. Props 的只读性react规定:组件无论是使用函数声明还是通过class声明，都决不能修改自身的props。组件的props 纯函数 1234// 这样的函数被称为“纯函数”，因为该函数不会尝试更改入参，且多次调用下相同的入参始终返回相同的结果。function sum(a, b) &#123; return a + b;&#125; 非纯函数 1234// 相反，下面这个函数则不是纯函数，因为它更改了自己的入参function withdraw(account, amount) &#123; account.total -= amount;&#125; React 非常灵活，但它也有一个严格的规则：所有 React 组件都必须像纯函数一样保护它们的 props 不被更改。 当然，应用程序的 UI 是动态的，并会伴随着时间的推移而变化。在下一章节中，我们将介绍一种新的概念，称之为 state。在不违反上述规则的情况下，state 允许 React 组件随用户操作、网络响应或者其他变化而动态更改输出内容。也就是说父组件传递过来的props是严禁修改,而组件自己内部的state(状态)是可以被修改的. state和生命周期stateState 与 props 类似，但是 state 是私有的，并且完全受控于当前组件。使用state需要组件是class组件,定义一个class组件如下所示: 12345678910111213141516import React,&#123; Component &#125; from 'react;class Mine extends Component&#123; constructor(props)&#123; // 构造器中必须super(props),这个是固定的写法 super(props); // state 必须定义在这里 this.state = &#123; name:'ALLEN' &#125; &#125; render()&#123; return &lt;div&gt;my name is &#123;this.state.name&#125;&lt;/div&gt;; &#125;&#125;export default Mine; 注意!在react的设计思想中,组件的state也是不可以直接修改的!这个叫做react的immutable设计思想. 它是为了性能更加好,所以一般我们如果要修改state的值,建议拷贝一个它的副本,然后修改他的副本,再将修改之后的副本重新赋值给state,从而完成state的修改. state 有一下几个点需要特别注意: 1.不能直接赋值修改state,而是使用this.setState()这样的一个方法来进行修改 1234this.state.name = 'bob'; //错误!this.setState(&#123; //正确 name:'bob'&#125;) 2.State 的更新可能是异步的出于性能考虑,不建议在this.setState()中直接传入一个对象,而是传递一个函数来进行修改. 123456this.setState(&#123; //normal name:'bob'&#125;)this.setState((state,props)=&gt;(&#123; //better name:'bob'&#125;)) 生命周期组件的生命周期,顾明思意,不必多言.下面列出react的几个生命周期的方法: 123456789101112131415161718192021class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date:'2019'&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;/div&gt; ); &#125; // react 的几个生命周期钩子 componentDidCatch()&#123;&#125; componentWillMount()&#123;&#125; componentDidMount()&#123;&#125; componentWillUpdate() componentDidUpdate()&#123;&#125; componentWillReceiveProps()&#123;&#125; componentWillUnmount()&#123;&#125;&#125; 有关react生命周期钩子的详细解释,请翻阅官方文档api章节. 单向数据流在react中一个重要的设计思想就是单向数据流! 不管是父组件或是子组件都无法知道某个组件是有状态的还是无状态的，并且它们也并不关心它是函数组件还是 class 组件。 这就是为什么称 state 为局部的或是封装的的原因。除了拥有并设置了它的组件，其他组件都无法访问。 组件不关心this.props的值到底是父组件的this.state还是this.props还是用户输入的数据. 事件处理在react中处理事件也很简单,例如下面的代码: 12// 事件处理&lt;button onClick=&#123;this.toggleBtnClick&#125;&gt;点击&lt;/button&gt; 可以看到和一般的js不同,在react定义一个方法名是小驼峰的写法,例如:onClick,onChange,onFoucs…被调用的方法使用{}进行包裹在 React 中另一个不同点是你不能通过返回 false 的方式阻止默认行为。(也就是return false)你必须显式的使用 preventDefault 才可以阻止默认事件.例如:12345678910111213function ActionLink() &#123; function handleClick(e) &#123; e.preventDefault(); // return false 不行! console.log('The link was clicked.'); &#125; return ( &lt;a href="#" onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125; this的问题在react的组件方法中如果你想用this的话,这个时候问题就来了,如果你没有进行bind操作,那么这个时候this的值就是undefined,那么如何解决这个问题,有下面三种方法: 12&lt;!--1. 在render中使用bind来进行绑定--&gt;&lt;button onClick=&#123;this.submit.bind(this)&#125;&gt;提交&lt;/button&gt; 12345678// 2.在构造函数中进行绑定constructor(props)&#123; super(props); this.submit = this.submit.bind(this);&#125;// 3.使用实验性的 publicClassFields 语法,同样也可以解决这个问题submit = () =&gt; &#123;&#125; 向事件处理方法传参有两种方法,废话不多说直接看代码: 12&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; 上述两种方式是等价的，分别通过箭头函数和 Function.prototype.bind 来实现。 在这两种情况下，React 的事件对象 e 会被作为第二个参数传递。如果通过箭头函数的方式，事件对象必须显式的进行传递，而通过 bind 的方式，事件对象以及更多的参数将会被隐式的进行传递。 条件渲染不像vue里面有封装好指令v-if或者v-show来供我们使用,在react中如果我们需要使用条件渲染的话,我们可以使用if(){...}或者三元运算符或者true &amp;&amp; expression(与运算符),如下所示: 123456789101112131415161718192021222324// 1.使用if来进行判断function Greeting(props) &#123; const isLoggedIn = props.isLoggedIn; if (isLoggedIn) &#123; return &lt;UserGreeting /&gt;; &#125; return &lt;GuestGreeting /&gt;;&#125;// 2.三元&#123; isLoggedIn ? &lt;UserGreeting /&gt; : &lt;GuestGreeting /&gt;;&#125;// &amp;&amp;,之所以能这样做，是因为在 JavaScript 中，true &amp;&amp; expression 总是会返回 expression, 而 false &amp;&amp; expression 总是会返回 false。因此，如果条件是 true，&amp;&amp; 右侧的元素就会被渲染，如果是 false，React 会忽略并跳过它。 &#123; isLoggedin &amp;&amp; &lt;UserGreeting /&gt;;&#125;// 如果什么都不渲染的话直接返回null就可以了&#123; isLoggedIn ? &lt;UserGreeting /&gt; : null;&#125; 上述就是在react中,虽然没有很方便的v-if,v-show指令,我们完成条件渲染的方法. var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-r11i', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>react.js</category>
      </categories>
      <tags>
        <tag>react.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node在前端架构中是如何做中间层的一点学习]]></title>
    <url>%2F2019%2F07%2F09%2Fnode%E5%9C%A8%E5%89%8D%E7%AB%AF%E6%9E%B6%E6%9E%84%E4%B8%AD%E6%98%AF%E5%A6%82%E4%BD%95%E5%81%9A%E4%B8%AD%E9%97%B4%E5%B1%82%E7%9A%84%E4%B8%80%E7%82%B9%E5%AD%A6%E4%B9%A0%2F</url>
    <content type="text"><![CDATA[今天上午看了几篇文章,写的是在前端架构中node是如何扮演一个中间层的角色,以及使用node来扮演一个中间层这样的架构设计有什么好处.下面作一个简单的介绍:首先我我们知道在广义的前后端分离中我们都是前端直接处理页面,通过Ajax,jsonp,fetch等从服务器端进行数据请求,然后在前端进行数据处理,从而渲染页面. var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'node-n20e', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入网址到渲染页面,中间发生了什么?]]></title>
    <url>%2F2019%2F07%2F09%2F%E4%BB%8E%E8%BE%93%E5%85%A5%E7%BD%91%E5%9D%80%E5%88%B0%E6%B8%B2%E6%9F%93%E9%A1%B5%E9%9D%A2-%E4%B8%AD%E9%97%B4%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[浏览器渲染大致的几个过程： DNS域名解析 建立TCP连接 发送HTTP请求 服务器处理请求 返回响应结果 关闭TCP连接 浏览器解析HTM 一、DNS域名解析 (通过DNS查询域名所对的IP地址) 我们在浏览器输入网址的时候，浏览器从历史记录和书签等地方搜寻自己的DNS缓存，找出已输入的字符串可以对应的url，然后根据智能提示，让你可以通过enter键，补全url地址。 查找本地hosts文件，检查该文件是否有相应的域名，ip对应关系，有的话取出 若上两步都没有，将域名发送给本地DNS服务器（中国电信，移动），查询本地DNS缓存，查找成功则返回结果。若不成功则通过迭代查询，多次访问不同的DNS服务器，取到域名对应的ip地址返回给本地DNS服务器 本地DNS将这个域名和IP地址缓存起来，然后把ip地址以响应报文的形式发送给客户端 var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'react-native-c16e', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何解决iOS模拟器卡顿?]]></title>
    <url>%2F2019%2F07%2F08%2F%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3iOS%E6%A8%A1%E6%8B%9F%E5%99%A8%E5%8D%A1%E9%A1%BF%2F</url>
    <content type="text"><![CDATA[自从升级到macSierra 10.12之后，在模拟器上面滑动视图很卡。后面就一直用的真机调试。但是有的时候跑一些小demo还是模拟器比较方便。所以就百度了一下怎么解决模拟器卡顿的问题. 1、看到网上有一个解决方法 在终端里面输入sudo sysctl -w kern.timer.coalescing_enabled=0 然后就不卡了,这是一个解决方法，第一次是很好用的，但是后面过了一段时间，模拟器又重新变得很缓慢卡顿。 2、第二种解决方法就是查看模拟器菜单栏的Debug选项卡，查看Slow Animations选项是否被选中，去掉勾，在运行模拟器以后就OK了，模拟器操作变得很顺畅.搞不明白苹果为什么要这样设计,建议直接使用第二种就可以了 var gitalk = new Gitalk({ // gitalk的主要参数 clientID: `e4890482436f9cd96039`, clientSecret: `0425bf39d0c5cdedf4ae60a72fbd7a3d58d7d99e`, repo: `codeCheeseIssues`, owner: 'wawsc5354524', admin: ['wawsc5354524'], id: 'ios-r10n', }); gitalk.render('gitalk-container');]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>iOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F06%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Hello World!]]></content>
      <categories>
        <category>other</category>
      </categories>
      <tags>
        <tag>other</tag>
      </tags>
  </entry>
</search>
